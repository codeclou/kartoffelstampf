<terminal-output>
    <!--
    * Licensed under MIT License
    * Copyright (c) 2017 Bernhard GrÃ¼newaldt
    -->

    <!-- HTML -->
    <div each={ line in linesInternal }>
        <div class={ getTypeContainer(line.type) }>
            <raw content="{ replaceNewlineWithBr(line.html) }"/>
        </div>
    </div>

    <!-- JAVASCRIPT -->
    <script>
        const self = this;
        import Anser from "anser";
        self.Anser = Anser;
        //console.log(self.Anser.ansiToJson(event.data));

        self.linesInternal = [];

        self.replaceNewlineWithBr= function(text) {
            if (text !== undefined && text !== null) {
                return text.replace(/\n/g, '<br/>');
            }
            return text;
        };

        self.shouldUpdate = function(data, nextOpts) {
            if (nextOpts !== undefined && nextOpts.lines !== undefined) {
                const newLine = nextOpts.lines[nextOpts.lines.length-1];
                const lineObj = JSON.parse(newLine);
                console.log(newLine);
                lineObj.json = Anser.ansiToJson(lineObj.payload.text);
                lineObj.html = Anser.ansiToHtml(lineObj.payload.text);
                lineObj.clearLine = false;
                if (lineObj.json !== undefined && lineObj.json !== null && lineObj.json.length > 0) {
                    for (let i=0;i<lineObj.json.length;i++) {
                        if (lineObj.json[i].clearLine === true) {
                            lineObj.clearLine = true;
                        }
                    }
                }
                const previousLineObj = self.linesInternal[self.linesInternal.length-1];
                if (lineObj.clearLine === true && previousLineObj.clearLine === true) {
                    self.linesInternal.pop();
                }
                self.linesInternal.push(lineObj);
            }

            return true
        };

        //
        // STYLES
        //
        self.getTypeContainer = (type) => {
            if (type === 'stdout') return self.css.stdout;
            if (type === 'stderr') return self.css.stderr;
            if (type === 'processStatus') return self.css.processStatus;
        }
        self.styles = () => {
            const styleProps = opts.felaMixin.mergeWithGlobalStyleProps({
                foo: 'red'
            });
            const styles = {
                stdout: props => ({
                    width: '90%',
                    backgroundColor: '#555',
                    color: '#efefef',
                    padding: '8px',
                    borderLeft: '10px solid green',
                    fontFamily: '"Lucida Console", Monaco, monospace',
                }),
                stderr: props => ({
                    width: '90%',
                    backgroundColor: '#555',
                    color: '#efefef',
                    padding: '8px',
                    borderLeft: '10px solid red',
                    fontFamily: '"Lucida Console", Monaco, monospace',
                }),
                processStatus: props => ({
                    width: '90%',
                    backgroundColor: '#555',
                    color: '#efefef',
                    padding: '8px',
                    borderLeft: '10px solid blue',
                    fontFamily: '"Lucida Console", Monaco, monospace',
                })
            };
            self.css = opts.felaMixin.renderAll(styles, styleProps);
        }

        //
        // INIT
        //
        self.styles();
    </script>

</terminal-output>